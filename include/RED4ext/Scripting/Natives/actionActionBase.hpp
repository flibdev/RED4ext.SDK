#pragma once

// This file is generated by Jack

#include <cstdint>
#include <RED4ext/Common.hpp>
#include <RED4ext/CString.hpp>
#include <RED4ext/ISerializable.hpp>
#include <RED4ext/Scripting/Natives/Generated/game/ActionReplicatedState.hpp>

namespace RED4ext {

namespace game {

enum class EActionStatus : uint32_t
{
  STATUS_INVALID = 0,
  STATUS_BOUND = 1,
  STATUS_READY = 2,
  STATUS_PROGRESS = 3,
  STATUS_COMPLETE = 4,
  STATUS_FAILURE = 5,
};

enum class EActionFlags : uint16_t
{
    NONE = 0,
    USE_ANIMATION = 1,
    USE_MOVEMENT = 2
};

} // namespace game

namespace action {

enum class Type : uint16_t {
  Default = 0x0,
  DroneMoveOnSpline = 0x2,
  MoveToPosition = 0x4,
  MoveToDynamicNode = 0x5,
  MoveAlongTrafficPath = 0x8,
  SlideToSimple = 0xD,
  HitReaction = 0x18,
  CameraControl = 0x1E,
  PlayerEquipItem = 0x1F,
  ItemUnequipMaybe = 0x21,
  WallRunMaybe = 0x26,
  PlayerResizeCapsule = 0x2A,
  PlayerClimb = 0x2B,
  PlayerAdjust = 0x2D,
  DriveToPointComplete = 0x38,
  DriveSummoning = 0x43,
  DrivePanic = 0x45,
  ActionVehicleSceneAnimationMotion = 0x47,
  IsSceneAnimationActive = 0x30,
  ShootMaybe = 0x34,
  ProjectileAttach = 0x35,
  DriveToPoint = 0x37,
  DriveChaseTarget = 0x39,
  DriveFollowTarget = 0x3A,
  DriveFollowTargetComplete = 0x3B,
  DriveMoveOnSpline = 0x3C,
  DriveSplineReverse = 0x3D,
  DriveFollowPosition = 0x3E,
  DriveFollowSlot = 0x3F,
  DriveStunned = 0x40,
  DriveJoinTraffic = 0x41,
  DriveCreateTrafficSlot = 0x42,
  DriveRacing = 0x44,
  DriveIdle = 0x46,
};

struct ActionInterface;

struct ActionBase
{
    virtual ~ActionBase();
    virtual void sub_08();
    virtual CString* GetActionName(CString*);
    virtual void sub_18();
    // process some stuct (event?) with vehicle ref @ 0x58
    // called when interface is set
    virtual void sub_20(uint64_t);
    // ran on completed, maybe
    virtual void sub_28();
    // start, create callbacks, events on entities, etc
    virtual void sub_30();
    // update - calls actionBase_UnknownState4 on condition
    virtual void sub_38();
    virtual void sub_40();
    // on finished (complete or failure)
    virtual void sub_48();
    // process gameChangeDestinationEvent maybe
    virtual void sub_50(uint64_t event);
    // get ReplicatedState class
    virtual RED4ext::CClass* sub_58();
    virtual bool sub_60();
    // called before sub_30 if sub_58 returns a class
    virtual void sub_68(game::ActionReplicatedState *replicatedState);
    // called after sub_40, sub_38
    virtual void sub_70(game::ActionReplicatedState *replicatedState);
    // called when 44 is set & status is set to ready
    virtual void sub_78();
    virtual void sub_80();

    // 1.52 RVA: 0x3C09E0 / 3934688
    // 1.6  RVA: 0x3C5910 / 3954960
    // 1.61 RVA: 0x3C5F70
    /// @pattern F0 FF 41 08 C3
    void __fastcall Lock();

    // 1.52 RVA: 0x1B034D0 / 28325072
    // 1.6  RVA: 0x1B2F080 / 28504192
    // 1.61 RVA: 0x1B2F170
    /// @pattern B8 FF FF FF FF F0 0F C1 41 08 83 F8 01 75 0C 48 8B D1 48 
    // inline int32_t __fastcall Unlock();


    // 1.52 RVA: 0x1B03630 / 28325424
    // checks for replicatedState class (runs sub_68 if so), runs sub_30
    // does some stuff with unk30
    /// @pattern 48 89 5C 24 10 48 89 74 24 18 57 48 83 EC 40 48 8B 01 48 8B D9 C7 41 28 03 00 00 00 FF 50 58 33
    void __fastcall StartWithReplicatedState();

    uint32_t unk08;
    uint32_t unk0C;
    ActionInterface *actionInterface;
    Type unk18;
    game::EActionFlags unk1A;
    uint32_t unk1C;
    // used during cleanup maybe or initialization
    uint64_t nextAction;
    game::EActionStatus status;
    uint32_t unk2C;
    Handle<ISerializable> unk30;
    uint32_t unk40;
    int32_t replicationId;
    int32_t unk48;
};

} // namespace action
} // namespace RED4ext
